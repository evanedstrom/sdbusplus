<%
    namespaces = interface.name.split('.')
    classname = namespaces.pop()

    def interface_instance():
        return "_".join(interface.name.split('.') + ['interface'])

    def error_namespace(e):
        n = e.split('.');
        n.pop(); # Remove error name.

        n = map((lambda x: interface.name if x == "self" else x), n);
        return '::'.join('.'.join(n).split('.'));

    def error_name(e):
        return e.split('.').pop();

    def error_include(e):
        l = error_namespace(e).split('::')
        l.pop() # Remove "Error"
        return '/'.join(l) + '/error.hpp';
%>
###
### Emit 'callback-cpp'
###
% if ptype == 'callback-cpp':
auto ${classname}::${property.camelCase}() const ->
        ${property.cppTypeParam(interface.name)}
{
    return _${property.camelCase};
}

int ${classname}::_callback_get_${property.name}(
        sd_bus* bus, const char* path, const char* interface,
        const char* property, sd_bus_message* reply, void* context,
        sd_bus_error* error)
{
    using sdbusplus::server::binding::details::convertForMessage;

    // TODO(venture): Can this except? I wouldn't think so.
    auto o = static_cast<${classname}*>(context);

    try
    {
        auto m = message::message(reply, o->_intf);

#if @WANT_TRANSACTION@
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id
                (std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        m.append(convertForMessage(o->${property.camelCase}()));
    }
    catch(sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    % for e in property.errors:
    catch(sdbusplus::${error_namespace(e)}::${error_name(e)}& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    % endfor

    return true;
}

auto ${classname}::${property.camelCase}(${property.cppTypeParam(interface.name)} value,
                                         bool skipSignal) ->
        ${property.cppTypeParam(interface.name)}
{
    if (_${property.camelCase} != value)
    {
        _${property.camelCase} = value;
        if (!skipSignal)
        {
            _${interface_instance()}.property_changed("${property.name}");
        }
    }

    return _${property.camelCase};
}

auto ${classname}::${property.camelCase}(${property.cppTypeParam(interface.name)} val) ->
        ${property.cppTypeParam(interface.name)}
{
    return ${property.camelCase}(val, false);
}
int ${classname}::_callback_set_${property.name}(
        sd_bus* bus, const char* path, const char* interface,
        const char* property, sd_bus_message* value, void* context,
        sd_bus_error* error)
{
    auto o = static_cast<${classname}*>(context);

    try
    {
        auto m = message::message(value, o->_intf);

#if @WANT_TRANSACTION@
        {
            auto tbus = m.get_bus();
            sdbusplus::server::transaction::Transaction t(tbus, m);
            sdbusplus::server::transaction::set_id
                (std::hash<sdbusplus::server::transaction::Transaction>{}(t));
        }
#endif

        ${property.cppTypeMessage(interface.name)} v{};
        m.read(v);
    % if property.is_enum():
        o->${property.camelCase}(${property.enum_namespace(interface.name)}\
convert${property.enum_name(interface.name)}FromString(v));
    % else:
        o->${property.camelCase}(v);
    % endif
    }
    catch(sdbusplus::internal_exception_t& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    % for e in property.errors:
    catch(sdbusplus::${error_namespace(e)}::${error_name(e)}& e)
    {
        return o->_intf->sd_bus_error_set(error, e.name(), e.description());
    }
    % endfor

    return true;
}

namespace details
{
namespace ${classname}
{
static const auto _property_${property.name} =
    utility::tuple_to_array(message::types::type_id<
            ${property.cppTypeMessage(interface.name)}>());
}
}
###
### Emit 'client-headers'
###
% elif ptype == 'client-headers':
        /** Get value of ${property.name}
    % for e in property.errors:
         *  @throws sdbusplus::${error_namespace(e)}::${error_name(e)}
    % endfor
         *  @return - ${property.name} property.
         */
        ${property.cppTypeParam(interface.name)} ${property.camelCase}() const;

% if 'const' not in property.flags:
        /** Set value of ${property.name}
         *  @param[in] ${property.name} - Property vaue.
    % for e in property.errors:
         *  @throws sdbusplus::${error_namespace(e)}::${error_name(e)}
    % endfor
         */
        void ${property.camelCase}(${property.cppTypeParam(interface.name)} var) const;
% endif
###
### Emit 'client-cpps'
###
% elif ptype == 'client-cpps':
% if property.is_enum():
${classname}::${property.cppTypeParam(interface.name)} ${classname}::${property.camelCase}() const
% else:
${property.cppTypeParam(interface.name)} ${classname}::${property.camelCase}() const
% endif
{
### // TODO: do this better, don't like the string literals.
### // Also would rather have a common function for get and set, but that would require
### // a variant type including class enums which has other repercussions.
    auto m = _bus->new_method_call(_service, _path, "org.freedesktop.DBus.Properties", "Get");
    m.append(_interface, "${property.name}");
    auto reply = _bus->call(m);
    if (reply.is_method_error()) {
        throw std::runtime_error("${classname}::${property.camelCase}() get message returned error.");
    }

    PropertiesVariant ret;
    reply.read(ret);
% if property.is_enum():
    return ${classname}::convert${property.enum_name(interface.name)}FromString(ret.get<std::string>());
% else:
    return ret.get<${property.cppTypeParam(interface.name)}>();
% endif
}

% if 'const' not in property.flags:
void ${classname}::${property.camelCase}(${property.cppTypeParam(interface.name)} var) const
{
### // TODO: do this better, don't like the string literals.
    auto m = _bus->new_method_call(_service, _path, "org.freedesktop.DBus.Properties", "Set");
    % if property.is_enum():
    m.append(_interface, "${property.name}", convertForMessage(var));
    % else:
    m.append(_interface, "${property.name}", var);
    % endif
    auto reply = _bus->call(m);
    if (reply.is_method_error()) {
        throw std::runtime_error("${classname}::${property.camelCase}() set message returned error.");
    }
}
% endif
###
### Emit 'callback-cpp-includes'
###
% elif ptype == 'callback-cpp-includes':
        % for e in property.errors:
#include <${error_include(e)}>
        % endfor
% endif
